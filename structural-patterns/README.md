# 🧱 Design Patterns - Structural Patterns

Welcome to the **Structural Patterns** section of the **Design Patterns** series. This repository showcases implementations of the most commonly used structural design patterns in software development.

> 🧩 Structural design patterns focus on how classes and objects are composed to form larger structures, while keeping them flexible and efficient.

---

## 📁 Patterns Included

| Pattern Name       | Description |
|--------------------|-------------|
| **Adapter**         | Allows incompatible interfaces to work together by converting one interface into another expected by the client. |
| **Bridge**          | Decouples an abstraction from its implementation so that the two can vary independently. |
| **Composite**       | Composes objects into tree structures to represent part-whole hierarchies. |
| **Decorator**       | Adds responsibilities to objects dynamically without modifying their code. |
| **Facade**          | Provides a simplified interface to a larger body of code. |
| **Flyweight**       | Minimizes memory usage by sharing as much data as possible with similar objects. |
| **Proxy**           | Provides a surrogate or placeholder to control access to another object. |

---

## 📂 Folder Structure


> Replace `.ext` with your language's file extension (e.g., `.py`, `.java`, `.cs`, etc.).

---

## 🧠 Pattern Overviews

### 1. Adapter
- Converts one interface into another.
- Useful for integrating third-party libraries or legacy code.

### 2. Bridge
- Separates abstraction from implementation.
- Promotes flexibility and scalability in layered designs.

### 3. Composite
- Treats individual objects and compositions of objects uniformly.
- Ideal for building tree structures like GUI elements or document hierarchies.

### 4. Decorator
- Dynamically extends an object’s behavior.
- Alternative to subclassing for extending functionality.

### 5. Facade
- Provides a high-level interface to a complex subsystem.
- Simplifies use for external clients.

### 6. Flyweight
- Shares common state between many similar objects.
- Great for resource-constrained applications like games.

### 7. Proxy
- Controls access to an object.
- Useful for lazy loading, access control, or logging.

---

## 🛠️ How to Use

Each pattern folder includes a self-contained example.

```bash
cd Adapter
# Run or test the example code

✅ Project Goals
✅ Explain the purpose and structure of each structural design pattern.

✅ Provide practical, understandable examples.

✅ Support developers in learning when and how to apply structural patterns effectively.

📚 References
Design Patterns: Elements of Reusable Object-Oriented Software — Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides

Refactoring Guru - Structural Patterns

SourceMaking - Structural Patterns

